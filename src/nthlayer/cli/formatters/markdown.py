"""
Markdown output formatter for NthLayer CLI.

Produces GitHub-flavored Markdown suitable for PR comments.
"""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .models import CheckResult, ReliabilityReport

from .models import CheckStatus


def format_markdown(report: ReliabilityReport) -> str:
    """
    Format reliability report as GitHub-flavored Markdown.

    Designed for PR comments with:
    - Summary table
    - Collapsible details
    - Status icons
    """
    lines = []

    # Header with hidden marker for comment updates
    lines.append("<!-- nthlayer -->")
    lines.append("## ðŸ›¡ï¸ NthLayer Reliability Check")
    lines.append("")
    lines.append(f"### {report.service}")
    lines.append("")

    # Summary table
    lines.append("| Check | Status | Details |")
    lines.append("|-------|--------|---------|")

    for check in report.checks:
        icon = _status_icon(check.status)
        status_text = _status_text(check.status)
        # Truncate long messages for table
        details = check.message[:60] + "..." if len(check.message) > 60 else check.message
        lines.append(f"| {check.name} | {icon} {status_text} | {details} |")

    lines.append("")

    # Collapsible details for failed/warning checks
    failed_checks = [c for c in report.checks if c.status in (CheckStatus.FAIL, CheckStatus.WARN)]

    for check in failed_checks:
        lines.extend(_format_check_details(check))

    # Footer
    lines.append("---")
    lines.append("")
    lines.append(
        "<sub>Generated by [NthLayer](https://github.com/rsionnach/nthlayer) â€¢ "
        "[Docs](https://rsionnach.github.io/nthlayer/)</sub>"
    )

    return "\n".join(lines)


def _status_icon(status: CheckStatus) -> str:
    """Get emoji icon for status."""
    icons = {
        CheckStatus.PASS: "âœ…",
        CheckStatus.WARN: "âš ï¸",
        CheckStatus.FAIL: "âŒ",
        CheckStatus.SKIP: "â­ï¸",
    }
    return icons.get(status, "â“")


def _status_text(status: CheckStatus) -> str:
    """Get text label for status."""
    texts = {
        CheckStatus.PASS: "Pass",
        CheckStatus.WARN: "Warning",
        CheckStatus.FAIL: "Fail",
        CheckStatus.SKIP: "Skipped",
    }
    return texts.get(status, "Unknown")


def _format_check_details(check: CheckResult) -> list[str]:
    """Format collapsible details section for a check."""
    lines = []

    # Determine emoji based on check type
    emoji = _check_emoji(check.name)

    lines.append("<details>")
    lines.append(f"<summary>{emoji} {check.name} Details</summary>")
    lines.append("")

    # Main message
    lines.append(f"**{check.message}**")
    lines.append("")

    # Format details as key-value pairs or tables
    if check.details:
        for key, value in check.details.items():
            if isinstance(value, dict):
                # Nested dict - format as mini table
                lines.append(f"**{_format_key(key)}:**")
                lines.append("")
                lines.append("| Key | Value |")
                lines.append("|-----|-------|")
                for k, v in value.items():
                    lines.append(f"| {k} | {v} |")
                lines.append("")
            elif isinstance(value, list):
                # List - format as bullet points or table
                if value and isinstance(value[0], dict):
                    # List of dicts - make a table
                    if value:
                        headers = list(value[0].keys())
                        lines.append(f"**{_format_key(key)}:**")
                        lines.append("")
                        lines.append("| " + " | ".join(headers) + " |")
                        lines.append("|" + "|".join(["---"] * len(headers)) + "|")
                        for item in value:
                            row = [str(item.get(h, "")) for h in headers]
                            lines.append("| " + " | ".join(row) + " |")
                        lines.append("")
                else:
                    # Simple list
                    lines.append(f"**{_format_key(key)}:**")
                    for item in value:
                        lines.append(f"- {item}")
                    lines.append("")
            else:
                # Simple value
                lines.append(f"**{_format_key(key)}:** {value}  ")

    # Recommendation if present
    if "recommendation" in check.details:
        lines.append("")
        lines.append(f"**Recommendation:** {check.details['recommendation']}")

    lines.append("</details>")
    lines.append("")

    return lines


def _format_key(key: str) -> str:
    """Format a key name for display."""
    return key.replace("_", " ").title()


def _check_emoji(check_name: str) -> str:
    """Get emoji for check type."""
    name_lower = check_name.lower()

    if "slo" in name_lower or "feasibility" in name_lower:
        return "ðŸ“Š"
    if "drift" in name_lower:
        return "ðŸ“ˆ"
    if "budget" in name_lower:
        return "ðŸ’°"
    if "metric" in name_lower:
        return "ðŸ“‰"
    if "blast" in name_lower or "impact" in name_lower:
        return "ðŸ’¥"
    if "dependency" in name_lower or "deps" in name_lower:
        return "ðŸ”—"
    if "owner" in name_lower:
        return "ðŸ‘¤"

    return "ðŸ“‹"
